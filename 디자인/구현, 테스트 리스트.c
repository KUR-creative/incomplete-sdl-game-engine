파일 로더 만들기



■ 구현 목록
1. ResourceLoadCaller
		이름이 겹치는 문제는 어떻게 할건데?
		
		//ResourceLoadCaller의 생성자를 쓰면, 싱글톤.h의 생성자에서 
		//ResourceLoadCaller의 생성자를 호출하게 되는데, 이 때 외부에서 주입한 ResourceLibrary::Instance()가 
		//복사된 다음 ResourceLibrary의 resLib가 되는 거 같다. 
		//그렇다면, 이것의 해결 방법은 바로 <완벽전달>이 될것이다. 그렇다면 std::forward를 써야하나?
		//함수의 signature를 바꿔야하나? &? &&? 이제는 정확히 알아야할 때가 왔다.
		
		XXXLoader들 전부 

-----------------------------2 번째는 개발자용만들기
		개발자용(_DEBUG)
			1_디렉토리를 재귀적으로 순회하며 파일 로드			-> 릴리즈와는 다른 ResourceLoadCaller
			2_릴리즈용 vector<string> paths 생성하여 
			이진파일 resource_paths.ini로 저장			-> 릴리즈와는 다른 ResourceLoadCaller
			3_리소스 로드, 리소스 사용에 대한 보고서도 csv파일로 만들어 준다.	
				보고서에는 기본적인 디렉토리 구조만 출력한다.
		릴리즈용(release)
			//릴리즈 파일로드콜러 테스트용 ini는 생성완료.
			//1_testIniSerialBuffer.ini를 로드하여 vector<string>가져오기
			//	확장자 값에 따라 파일 로드 
							//1. 프로젝터(SDL_Windoe,SDL_Renderer) ->후에 소멸자에서 처리할 것.
							//2. PngLoader(반드시 프로젝터의 renderer 참조를 가져야 한다!)등 XXXLoader <- 꼭 싱글톤일 필요는 없을 듯.
								//ㄴXXLoader가 가진 경로를 바꾸는 함수 필요.
								//ㄴ경로string 대입 없는 생성자.
								//ㄴ그 경우 load()할 때 경로string이 있는지 없는지에 대한 예외처리가 필요.
							//3. ResourceLoadCaller의 extensionMap
						//제페의 것을 사용하되 create함수는 좀 다르게 한다. 이미 있는데 또 만들어버리면 assert-심각한오류로종료-해버리자.
					//만일 어떤 확장자에 대한 설정값이 없다면? =>릴리즈용이니까 걍 콘솔에만 표시해 준다.
			//	로드가 제대로 되었는지 확인

//*내 시스템의 싱글톤 요구사항
	//-생성 순서가 지켜져야 한다.(하나가 다른 하나에 의존한다)
	//-게임 엔진이다. 초기화 단계에서 생성한다.
	//-내부 지역 static 객체의 생성과 참조를 하나의 함수로 만들지 않는다.
	//-소멸은 걍 알아서 하슈(unique_ptr)
	//-생성자는 당연히 막는다.
	
나중에 엔진을 위한 테스트 코드는 TEST를 끄면 컴파일되지 않게하기. gtest의 기본 기능일지도?
	
*단위 테스트는 각각의 클래스.cpp로 옮기기...!
renderer는 대강 extern 시키기.. 아니면 프로젝터를 만들던지.
	
프로젝터는 한개여야 할까?
만약 윈도우가 여러개 있다면, 그 안에 들어가는 표시객체트리도 윈도우 수만큼 있어야 한다. 
그건 엄청 복잡한 일인데..
	
싱글톤이 될 녀석들
	적어라..
			
//2. FileLoader, XXXLoader, 구체원시객체(LoadedData상속)구조 완전한 OOP방식으로 고치기
//로더에 unique_ptr을 도입하고 move의 진정한 의미를 깨닫자...
템플릿을 써서 XXXLoader를 만드는 방법이 없을까? 그러면서도 전략패턴이 되도록...
	즉 템플릿을 이용한 전략패턴은 어떻게 가능한가? 그것이 policy-based 프로그래밍인가?
	이것은 아무래도 FileLoadCaller를 만들어봐야지만 확실히 할 수 있을 거 같다..
올바르지 못한 type을 꺼내면 operator[]에서 false를 반환하게 할수는 없을까??

//3. LoadedDataLibrary
//	해시맵을 이용한 저장
//	함수 템플릿을 이용하여 구체원시객체를 반환하는 getItem(const string&) <= 사용가능 확장자리스트가 있어야 되려나?
//	ㄴ이거 안 되면 결국 cast써야함...
같은 해쉬키가 들어가는 예외는 어떻게 처리하는가? 원래 원천적으로 막아야 한다.

4. FileSaver: boost라이브러리를 이용하여 직렬화시키는 클래스 만들기...

-설계 세부 결정 사항-
primitive라 할것이냐? LoadedData라 할것이냐??


<다음 구현 목표>
표시객체와 무비클립, 사운드 객체.
이것은 SDL에 대한 연구가 필요한 부분이다.
텍스쳐에 효과를 준다면, 렌더링할 때 하는가? 아니면 텍스쳐 자체를 바꾸는가?
아마 둘 다 있겠지, 그러면 어떤 표시객체는 Png를 공유하고, 다른 어떤 표시객체는 Png를 공유하지 않는다면?

>> 연구하기.
//SDL_Texture*를 매개변수로 받는 간단한 함수들로 몇줄만 코딩하면 아주 간단히 할 수 있다.
	//각 돌리기, 뒤집기 -> SDL_RenderCopyEx의 angle, flip
	//이동			-> SDL_RenderCopyEx의 dstrect에 x,y를 주입
	//알파			->
	//밝기			-> SDL_SetTextureColorMod에서 R,G,B를 서서히 줄이거나 늘린다...
	//RGB 변형
	ㄴ근데 이 RGB 값 바꿔서 보여주는거 개느림.. 차라리 하나 만들어서 박아주는게 빠름...
	렌더러에서 처리해줄 수는 없나? 없는건가..
	
<만들어보기-연구>
DisplayObjectContainer상속
	Sprite			그냥 텍스쳐이다. 
	MovieClip		여러 부분으로 나눠놓아 애니메이션을 보여줄 수 있는 텍스쳐와 시스템을 가진다.
	Button			노멀,오버,다운,히트 의 4개 상태를 갖는 버튼. 마우스이벤트를 처리해야한다.. 다른 표시객체 포함 가능.
	InputText		문자열 등을 입력할 수 있는 텍스트.
	DynamicText		동적으로 바뀌는 텍스트
2DisplayObjectContainer 상속 안 함!
	SimpleButton	노멀,오버,다운,히트 의 4개 상태를 갖는 버튼. 마우스이벤트를 처리해야한다.. 다른 표시객체 포함 불가. 
	StaticText		안 바뀌는 텍스트.
	
	상황을 단순하게...
	내가 하고 싶은 건 그저...
	버튼을 누르면 값이 출력된다.//옆의 신호등 색이 바뀐다. 신호등은 움직일 수 있다.
	다른 버튼을 누르면 다른 값이 출력된다.

DisplayObjectContainer
	//추상클래스이다.
	//DisplayObject를 상속한다.
	//트리구조를 이룰 수 있다. 렌더링의 순서가 정해져 있다.	
		//=> list를 써야될 거 같다.
		//=> list<weak_ptr>을 써야겠다. 객체 관리는 사용자가 하니까, 포인터가 가리키던게 죽으면 빼버리고 막 그래야지.
		=> list에 접근하는 iterater를 멤버로 보관해서 빠르게 하자(Effective STL을 본 다음에 한다.)
		//=> DOC트리를 저장소(인덱스 같은 걸로 가져오기)로 쓸 수는 있지만 권장되지 않는다. 빡센 예외가 사용자를 기다린다..
			->부모에 접근할 수 있어야 하는가? =>그래야할 거 같다.
				=>자식은 부모의 좌표를 기준으로 움직이는게 이해하기 쉽다.
			->만일 어떤 DO에 대한 참조를 
			//->자식들을 렌더링 순서대로 보관하는데 어떤 자료구조를 쓸 것인가? :list	
				왜 list냐? 순차접근, 삽입, 삭제가 빠르니까.
				삽입/삭제/순차접근/랜덤접근~검색
				ㄴ가장 빈번한 연산은 무엇인가? 바로 순차접근이다(렌더링) > 근데 순차접근은 둘 다 별 차이가 없어..
				
				list냐? vector냐?	=> list를 써야될 거 같다.
				해쉬맵으로 cache를 만들것이냐? 즉 getByName같은 걸 가능하게 한다. 
					>뭐 해쉬맵 없어도 걍 선형 검색 돌려도 안될거 없다.. 그걸 그렇게 많이 하는 것도 아닐테고...
					>이른 최적화는 만악의 근원이다.
					>애초에 플래시랑 달리 내 DOC트리는 자기가 동적할당한 DO들을 집어넣는거니까 참조를 굳이 찾아낼 필요가 없다.
					> 애초에 검색은 거의 필요없어 보인다.
			아예 접근을 못하게 할까? DOC트리는 그저 렌더링과 관리도구일 뿐, 저장소가 아니니까
			자료의 관리 같은 건 사용자가 알아서 해야지... 여기에 있는 건 참조밖에 없어..
			root DOC는 unique_ptr로 Projector가 가진다. 다른 놈들은 사용자 니들이 알아서 만들어 써라.
			그렇다면 weak_ptr을 쓸 때가 드디어 온 거 같다.
-->	//(Root를) 렌더링하면 재귀적으로 하부의 모든 DisplayObject가 렌더링된다.
	
	부모의 변화는 하부 자손들 모두에게 재귀적으로 영향을 미친다.
		=> realRect:렌더링용 SDL_Rect다.
			=> x y
				부모가 생기면, 부모의 center를 자신의 (0,0)으로 할까? 그게 편할까? 
				그렇다면 root는 화면(왼쪽위가 0,0)과 같게 만들겠지?
				=>자식의 center를 부모의 center과 일치시키자(기본값)
				//=>그리고 자식의 x,y는 부모의 x,y를 기준으로 한다.
				ㄴ이게 가능하려면 부모를 가리키는 포인터는 모든 DisplayObject가 가져야 한다.
				뭐 그래야지..
					*그래서 실제 렌더링되는 좌표(realX,realY)와 가지고 있는 좌표(X,Y)는 다르다!
					*이런 렌더링 좌표를 얻는 getter는 protected가 맞을 거 같다. RealX,RealY.
			=> w h
		=> angle
		=> flip
		=> alpha
		=> r g b
			x,y,w,h는 어렵지 않지만, angle은 수학식이 필요하다...
			getter setter 메서드들의 네이밍은 어떻게 할 것인가?
			ㄴ항목 36:상속받은 비가상 함수를... 재정의 ... 금물 ... 읽기.
		
	재귀적인 연산의 최적화 방법은?	
		=> 일단 재귀로 만들어보고 성능 문제가 심각하면 최적화해본다
		=> 이른 최적화는 만악의 근원이다!
				->애초에 그렇게 부하가 많이 걸릴까? 모르는 일이지...
				->구조가 깊어져서 성능 문제가 생기는 시점부터 캐시를 만드는것도 한 방법일 듯.
				->꼬리재귀?
				->cache 만들기? 그런데 그거 만드느라고 느려지면 배보다 배꼽이 커지는거지..
		
	DisplayObject로 이뤄진 트리에서 캐스트없이 DisplayObjectContainer를 구분하기 위해 객체의 참조를 보관한다.
		(이건 Projector와의 콜라보레이션이다.)
		=>DisplayObjectContainer 참조 컨테이너의 자료구조는 forward_list가 적절해 보인다.
		=>참조 컨테이너의 위치는 Projector다.
				순서X 검색X 삽입O 딱이네~!
			사용자는 애초에 자신이 생성한 DisplayObjectContainer의 참조를 가지고 있음을 명심하자.
				*그러므로 자식을 넣는 건 사용자측에서 쉽게 할 수 있다.
				*또한 사용자가 root에서 객체를 꺼내는 일 자체가 이상한 일이다.
				*DOC트리는 메모리 풀이 아니다! 그냥 순차 렌더링과 재귀적 상태변화를 위한 자료구조이다.
			이것이 필요한 이유는 DisplayObject에는 없으나 DisplayObjectContainer에는 있는 기능을 사용하기 위해서다.
				*Projector는 오직 DisplayObjectContainer인 root만을 가진다! 그런데 저걸 해야돼!
				자손 전부 삭제deleteAllChild 같은 메서드는 DO에는 선언되지 않으나 
				root에서 써야되고 재귀적으로 모두 가능해야한다. 그러니까 컨테이너는 Projector에 있어야할 거 같다...
						만일 그런 컨테이너가 있으면 자손 삭제는 그 컨테이너에만 하면 끝임(재귀가 아니다.)
						또, 이런 경우에는 해쉬맵이 의미가 있는가? 과연 검색을 많이 하겠는가? 글쎄...
					
				->애초에 다른 구체 객체들은 어쩔건데? 
			그 컨테이너는 Projector가 가진다.
		=> root 컨테이너는 center가 (0,0)이다..
	자식을 삭제할 수 있다.

*개념적 member변화는 render member에 영향을 미친다. 하지만 그 영향은 렌더링할 때 적용된다.
즉 렌더링하기 전에 계산하면 된다. 개념적 멤버를 변화시킬때마다 렌더링멤버를 변화시킬 필요가 없다.
*렌더링할 때마다 매번 계산하지만 렌더링을 위한 값을 저장하기 위해 임시변수를 만드는건 낭비다.
그래서 render member를 도입했다.
*자식이 받는 부모의 렌더멤버에 대한 영향은 자식이 부모에 접근하여 처리한다. 그러기 위한 DisplayObject* parent다.

구현 요구사항
단순좌표이동

크기변화

각도변화(회전)

codesafer
회전 중심 기준으로 그냥 회전시키면 되는뎅
츄럴
해결하고 싶어짐
츄럴
회전은 걍 회전변환 썼는데... 음....
츄럴
상당히 뭐가 꼬인 관계로... 해결이 안되네여
codesafer
회전변환의 기본이
codesafer
회전중심의 영점 이동
codesafer
회전,
codesafer
원점 이동이잖아
codesafer
니가 캔버스 위에 놓인
codesafer
여러 개체를 같이 회전시키고 싶다면
codesafer
캔버스 통째로 영점 이동하고
codesafer
전체 정점들을 회전하고
codesafer
원점으로 되돌리면 됨.
codesafer
그러니까 생각할때,
codesafer
니가 바라는 회전이
codesafer
무엇을 중심으로 놓고 회전시키면 되는가.
codesafer
그게 중요한거지
	
http://stackoverflow.com/questions/20233469/how-do-i-take-and-save-a-bmp-screenshot-in-sdl-2
GUI테스트를 위의 방법으로... 
1. 예측되는 걸 SDL_Window의 SDL_Surface를 비트맵으로 저장하고 
2. 실제의 것을 또 저장해서 
3. 서로 비교...
근데 귀찮아서 안 될듯...
  
	
일반: 이놈들을 만드는 건? 
원시객체 -> 사용객체 (다:일 관계)
기본적으로, default로 만드는 것들이 있다.

Png -> Sprite
Png+Json(이름이 같아야함) -> MovieClip
Mp3 -> Sound
...

사용자가 새로운 사용객체를 만들 수 있다.
Resource report는 각 리소스가 사용된 것을 기록한다.

	버튼:이벤트의 처리를 어떻게 할 것인가???		<-----마우스이벤트?
		버튼과 어떤 다른 무엇과의 연결은...?		<-----messaging 시스템?
	무비클립: json읽기, 시간을 이벤트로 처리할까?	<-----시간진행이벤트? 남들은 어떻게 하는가?
	텍스트류: ttf를 쓰는 법을 알아보자.
	
	그렇다면 객체간의 소통은 message라 하자.. MessageDispatcher?
	
	
사운드 객체의 재생 시점? 반복을 정하는 것은?
프레임 기반 애니메이션?
프레임 기반 사운드 재생?
일정 시간에 의한 반복?


이제 할 일
렌더링 부분 주석 써서 문서화하기
약간 복잡할 수 있는 DisplayObject에 대한 문서 쓰기.
DisplayObject 깔끔하게 정리하기.
(r,g,b, alpha 처리하기)
DisplayObject와 DisplayObjectContainer, root, Projector의 콜라보레이션.
메시지 디스패처 설계 -> 게임루프 설계



<프로젝터와 표시객체트리>
root표시객체는 게임 화면에 등장하는 모든 표시객체를 포함한다.		->root 이하에 포함되지 않은 표시객체는 렌더링되지 않는다.
프로젝터는 root객체를 루트노드로 가지는 표시객체트리를 순서대로 렌더링해준다.	-> 엔진 사용자는 표시객체트리를 마음대로 조직할 수 있다.
게임루프매니저는 게임루프를 제어한다. 
게임루프는 시간에 따른 요청을 제어한다. 
게임상태는 1_표시객체들의 변수, 2_엔진 사용자가 만들어낸 객체들이 가진다. 이런 상태를 제어해야하는데...
게임루프는 그저 이벤트만 전하는게 나을 것 같다. 시간이 지났다는 이벤트가 전해지면 이걸 옵저버들(상태바꾸는놈,프로젝터,사운드매니저 등)이 알아듣고 해야할 일을 한다.
	ㄴ게임루프는 그러면 이벤트를 알리기만 하는가? 프로젝터에 대한 예외없이? 일관된 인터페이스를 위해?
	ㄴ프로젝터나 사운드매니저의 경우 반드시 하나만 존재한다. 예외를 두고 직접 참조를 받아서 관리할 것인가? 글쎄...

ㄴ위에 따른 요구사항
	표시객체트리 -> 표시객체는 내부에 표시객체리스트를 가진다. 컴포짓패턴을 일단 배워보자.
	표시객체 트리를 만들고 나서 이걸 순회하는 방법을 알아보자. 어쩌면 꼬리재귀 최적화를 하는 법을 배워야할지도.
	이벤트와 이벤트디스패쳐를 옵저버패턴으로 구현해야할지도 모른다.
	
ㄴ즉 공부해야할 것
	0.1_합성패턴 없이 만들기
	
	0.2_반복자 없이 만들기
	1_합성패턴
	2_컴포짓패턴으로 구현한 트리의 순회
	3_순회에 사용될 꼬리재귀최적화?? 일시적으로 저장하는 연결리스트를 쓰면 되지 ㅋ
	  파일 읽는 걸 개발자용에서만 재귀 쓰듯이 하는거다... 여기서도...
	
	나중에 DisplayObjectContainer구현하라. 이거 뭐... 플래시랑 거의 같아지는구만..

	
■ 테스트 목록
어디서 파일 이름의 확장자와 원시객체의 1:1 대응 관계를 알것인가?
1. FileLoadCaller
3. ResourceLibrary: 원시객체의 저장, 열람
	싱글톤.
	.LoadedData타입으로 일관된 저장
	<typename Data*> 
	Data operator[](const Data& input) LoadedData의 파생클래스 타입으로 열람 

*. Singleton Template 만들것.
//getFilePaths함수
//resource(혹은 다른 이름)폴더의 구조에 상관없이 모든 서브디렉토리의 파일 경로를 가지는 vector<char*> filePaths
	//vector<char*> getFilePaths(char* dir)
	//함수 signature 테스트
	//폴더,파일에 접근시 vector<char*>에 경로(이름)를 저장한다
	//	이 때 값에 의한 전달로 vector에 문자열들을 넣어야 한다(힙에 할당하라)
	//폴더를 만나면 재귀적으로 호출된다
	//더 이상 항목이 없으면 반환된다.
	//각각의 파일로더는 예외처리를 하라-예외처리에 관한 ASSERT테스트 필요(FileLoader에서 강제할 수는 없는가??)

FileSaver : 
	/과연 이 인터페이스는 필요할까? 저장하는 데이터는 txt(글,이름..), bin(객체,게임상태저장..), csv=txt(트리,표..) 정도...?
	경로를 주고 파일생성을 하려하면 어떻게 되는가??
		경로가 존재하지 않으면?
		경로는 존재하되 파일이 존재하지 않으면?
		경로도 존재하고 파일도 존재한다면?
	생성이 된 경우의 테스트는?
		생성한 파일을 로드하여 만든 데이터와 / 파일 입력에 사용한 데이터가 동일해야 한다. 
		= 생성한 파일을 로드하여 만든 데이터와 / save함수에 넣어준 데이터가 동일해야 한다. 
			bool save(경로, 이름, 데이터);
	생성이 되지 않은 경우는?
		경로가 잘못되었을 때
		뭔가 다른게 잘못되었을 때                                                                                                                                  
	
DirCsvSaver
	생성한 파일을 로드하여 만든 csv데이터 string과 / 파일 입력에 사용한 string이 동일해야 한다. 
	= 생성한 파일을 로드하여 만든 csv데이터 string과 / save함수에 넣어준 string이 같아야한다.
		bool save(경로, 이름, string)
		만일 경로가 파일 이름을 포함할 경우 처리해야한다. private bool isFolder(string)


모든 파일을 로드할 수 있는 클래스 resourceLoader
	//모든 파일형식을 로드할 수 있는 인터페이스같은 뭐시기가 필요하다...
	//각각의 파일 형식은 각각의 로드 방식을 가진다. 이것은 전략패턴 (+ 팩토리메서드 패턴)일듯.

	vector<char*> filePaths에서 확장자를 이용하여 각각의 파일들을 그들의 방식대로 로드한다.
	1.	디렉토리를 순회하면서 디렉토리의 트리구조를 표현한 csv파일(FileSaver)을 만든다.(나중에 엑셀로 보면 된다)
		이 csv파일은 개발자 모드에서만 생성하게 한다.
		각각의 리프노드(파일)에서 FileLoader를 이용하여 파일에 알맞는 객체를 만들어
		해쉬맵 Wrapper클래스(ResourceLibrary)에 넣는다.
			나중에 게임 내 리소스를 관리하는 툴 프로그램(GUI)을 만들수도 있겠다.
			툴 프로그램은 드래그 등으로 리소스파일을 resources하부 폴더에서 다른 하부폴더로 옮길수도 있고...
			새로 추가하는게 가능할지도 모른다. GUI를 이용하자. SDL에 이런 일을 지원하는 무언가가 있을지도 모른다.
		

DisplayObject를 렌더링해주는 프로젝터와 레이어 구현을 분리하자. 플래시처럼 하는거다
그리고 DisplayObjectContainer 클래스를 만들어야할 듯
		
//txt 파일을 로드하여 만든 string을 [테스트용 string 객체]와 비교한다(복붙으로 만든다)
	//TxtLoader는 Text에 가져온 txt파일 데이터를 저장한다.
bin 파일을 로드하여 만든 객체를 또다른 객체와 비교한다.

//png 파일을 로드하여 만든 DisplayObjectOrigin이 [테스트용 DisplayObjectOrigin 객체]와 같은지 비교한다
	//PngLoader는 Png에 가져온 png파일의 SDL_Texture*를 저장한다.
//SDL_QueryTexture의 w,h를 써서 비교한다.
	//-> 그냥 내가 보고 판단한다!
	
	
	

■ 그외 할 일(+실험)
//SDL 전용 파일 로드 시스템이 있는가?
SDL_Texture의 어떤 뭐시기를 쓰면 각각의 픽셀을 이루는 bit들을 비교할 수 있지 않을까??
mock객체를 사용하면 테스트를 간편하게 할 수 있는가?
파일을 로드하는 방법을 추상화시키면 그 파일에 대한 테스트 방법도 추상화시킬 수 있을텐데?
	->mock이란 무엇인가?
	->google mock 설치하기.
	
DisplayObject에 좀더 풍부한 표현이 가능하게 하자.
Texture를 조작하는 다양한 방법을 알아보자. 알파, blending 등.
	
	

파일 디렉토리는 윈도에서 "\\"를 통해 구분된다.
어떻게 하면 리소스들을 좀더 자유롭게 담을 수 있을까?
리소스를 내 멋대로 디렉토리에 담아놓은 다음, 맘대로 로드하는 방법은?
리소스 관리방법은? 

폴더 경로를 넣으면, 그 폴더의 하위 디렉토리 중 파일이 있는 폴더 경로를 char* 배열(string 배열)로 반환한다.
	-> 이 때 boost 라이브러리를 쓰지 않는 이상 운영체제(windows)에 종속되게 되는데
	-> 아예 리소스 경로 데이터를 뽑는 걸 따로 해주는 것도 한 방법이겠다.
	
	
TDD.... 어차피 만들꺼면 클래스에서부터 생각하자... 
전역함수를 쓰니까 다 갈아엎게 생겼네


SDL_RWops 공부
객체를 쓰는 횟수?
size_t SDL_RWwrite(struct SDL_RWops* context,	
                   const void*       ptr,		/*파일에 넣을 데이터 버퍼*/
                   size_t            size,	/*버퍼를 어떤 크기로 자를것인가?*/
                   size_t            num)	/*size크기로 잘린 버퍼의 몇개를 파일에 기록할 것인가?
											만일 버퍼 크기보다 size*num크기가 크면 버퍼 이상 입력이 되긴 하지만
											의미 있는 값은 버퍼 크기까지일 뿐임.*/



											
경로를 주고 파일생성을 하려하면 어떻게 되는가??
	/경로(폴더)가 존재하지 않으면?			:런타임 에러 발생
	경로는 존재하되 파일이 존재하지 않으면?	:상관없이 새 파일이 만들어진다.
	경로도 존재하고 파일도 존재한다면?		:기존의 파일은 지우고 새 파일을 만들어서 저장한다.

	
■ 언젠가 해 볼 일...
1. csv만 뽑는게 아니고, GUI를 구성해서 쓸모있는 게임 개발자용 리소스관리 패널 만들기
2. template을 이용하는 FileLoader와 그 외 구성물의 설계... 
	만일 결국 LoadedData를 인터페이스로 쓰는 방향으로 진행됬다면, 리팩토링을 배울 수도 있을 것.
	

테스트 자동화의 필요성!